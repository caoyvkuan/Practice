# 原理

+ 变量函数提升机制 预编译
+ 变量、作用域和内存的问题

## 变量函数提升机制

+  (var  function 不包括函数表达式)

1. 执行过程

   1. 从第二次宏任务开始每次执行宏任务前会清空微任务

2. 预编译

   + 页面产生便创建了GO全局对象（Global Object）（也就是window对象）

   + 脚本文件加载

   + 脚本加载完毕后，分析语法是否合法

   + 开始预编译

     - 查找变量声明，作为GO属性，值赋予undefined
     - 查找函数声明，作为GO属性，值赋予函数体

   + 函数变量的提升

   + ```javascript
     // 1. 变量声明、函数声明都会被提升到作用域顶处；
     //  2. 当出现相同名称时,同名变量会被赋值为同名函数
     var func;
     function func(){ return 1}
     alert(func); //-> f func(){ return 1}  整个方法
     alert(func()) // -> 1   方法的返回值 / 无返回值为 undefined
     // 所有赋值保留原位 , 隐式变量同意保留原位
     var a =1;//->a会被提升赋值的1保留原位  
     b = 1; // ->b于1都保留原位
     ```

     

   + ```javascript
     //伪代码
     GO/window = {
         //页面加载创建GO同时，创建了document、navigator、screen等等属性，此处省略
         a: undefined,
         c: undefined，
         b: function(y){
             var x = 1;
             console.log('so easy');
         }
     }
     ```

   + 解释执行代码（直到执行函数b）

   + ```javascript
     //伪代码
     GO/window = {
         //变量随着执行流得到初始化
         a: 1,
         c: function(){
             //...
         },
         b: function(y){
             var x = 1;
             console.log('so easy');
         }
     }
     ```

   + 执行函数b之前，发生预编译

     + 创建AO活动对象（Active Object）
     + 查找形参和变量声明，值赋予undefined
     + 实参值赋给形参
     + 函数与变量的提升
     + 查找函数声明，值赋予函数体


## 变量、作用域和内存的问题

+ 基本类型和引用类型
+ 执行环境及作用域
+ 垃圾收集

### 基本类型和引用类型

+ 变量可能包含两种不同数据类型	
  + 基本类型指的是简单的数据段
  + 引用类型指的是那些可能有多个值构成的对象

+ 在将一个值给变量时,解析器必需确定这个值是基本类型值还是引用类型值
  + 基本数据类型`Undefined、Null、Boolean、Number 和 String` 这5中数据类型是按值访问的，因为可以操作保存在变量中的实际值
  + 引用类型的值保存在内存中的对象，js不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，在操作对象时，实际上操作的是对象的引用而不是实际的对象，为此，引用类型的值是按引用访问的

+ 动态属性
  + 对于引用类型的值，可以为其添加属性和方法，也可以删除其属性和方法

+ 复制变量值
  + 将一个变量基本类型的值赋值给另一个变量时，两个变量虽然值相同，但是是完全独立的，只是创建了一个副本，这两个变量的任何操作都不会相互影响
  + 当从一个变量向另一个变量赋值引用类型的值时，同样也会将储存在变量对象中的值复制一份放到新变量分配的空间中，不同的是，这个值的副本实际上是一个指针，而指针指向储存在堆中的一个对象，两个变量实际上将引用同一个对象，因此改变其中一个变量，就会影响另一个变量

+ 传递参数
  + js中所有函数的参数都是按值传递的，也就是说把函数外部的值赋值给函数内部的参数，就和把值从一个变量复制到另一个变量一样
  + 证明函数的参数是按值传递的，而不是按引用传递的
```js
  function setName(obj){
    obj.name = 'Nice';
    obj = new Object();
    obj.name = 'Yuan';
  }
  let person = new Object();
  setName(person);  //证明函数是值传递，原有的引用在new了新对象后还保留着
  console.log(person.name);    //Nice
```
### 执行环境及作用域

+ 执行环境定义了变量或是函数有权访问的其他数据，决定了他们各自的行为，每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，虽然编写的代码无法访问这个对象，但是解析器在处理数据时会在后台使用它
+ 全局执行环境是最外围的一个执行环境，在Web浏览器中，全局执行环境被认为是`window`对象，因此所有的全局变量和函数都是作为`window`对象的属性和方法创建的。
+ 某个执行环境中的所有代码执行完成后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）
+ 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈就将其环境弹出，把控制权返回给之前的执行环境
+ 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问，作用域链的前端，始终都是当前执行的代码所在环境的变量对象，如果这个环境是函数，则将其活动对象（`activation object`）作为变量对象，活动对象在最开始时只包含一个变量，即`arguments`对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来至外部作用域，全局执行环境的变量对象始终都是作用域链中的最后一个对象（即作用域的最外层）

+ 延长作用域链
  + 虽然执行环境的类型只有两种——全局和局部（函数），但是还有其他方法来延长作用域链
  + 有些语句可以在作用域链的前端临时增加一个变量对象，该变量会在代码执行后被移除
    + `try-catch 语句的 catch块 `
    + `with`语句
    + 这两个语句都会在作用域链的前端添加一个变量对象对`with`语句来说，会将指定的对象添加到作用域链中。对`catch`语句来说，会创建一个全新的变量对象，其中包含的是被抛出的错误对象的声明
+ ES6前没有块级作用域
  + 也就是`if  或 for `等语句中声明的变量外部也能访问，而不会被销毁
  + 初始化变量没有使用let声明，会自动被添加到全局环境中

### 垃圾收集

+ js具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存
+ 函数中局部变量的正常生命周期，局部变量只在函数执行的过程中存在，而在这个过程中，会位局部变量在栈或堆内存上分配相应的空间，以便存储它们的值，在函数执行结束后，局部变量也就没有了存在的必要，因此可以释放它们的内存以供将来使用，这种情况下很容易判断变量是否还有存在必要，但并非所有情况度这么容易，垃圾收集必须跟踪哪个变量有用哪个没用，对不再有用的变量打上标记，以备将来收回其占用内存

+ 标记清除
  + js中最常用的垃圾收集方式就是标记清除，当变量进入环境时（例如在函数中声明一个变量时），就将这个变量标记位“进入环境”。从逻辑上将，永远不能释放进入环境的变量所占用的内存，当变量离开环境时，则将其标记位“离开环境”
  + 垃圾收集在运行时会给储存在内存中的所有变量都加上标记，然后会清楚掉环境中的变量以及被环境中的变量引用的变量的标记，之后再被加上标记的变量将被视为准备删除的变量，最后垃圾收集完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间
+ 引用计数（垃圾收集策略之一）
+ 性能问题（垃圾收集的触发条件会影响性能）
+ 管理内存
  + 确保占用最少的内存可以让页面获得更好的性能
  + 而优化内存在最佳方式，就是为执行中的代码只保存必要的数据，一旦有数据不再有用，最好通过将其值设置为`null`来释放其引用——这个做法叫做解除引用
  + 解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收

### 小结

+ 基本类型值在内存中占据固定大小，因此被保存在栈内存中
+ 从一个变量向另一个变量中复制基本类型的值，会创建这个值的一个副本；
+ 引用类型的值是对象，保存在堆内存中；
+ 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针
+ 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象
+ 确定一个基本类型的值可以使用 typeof ，引用类型用 instanceof

+ 所有变量都存在于一个执行环境（作用域）当中，这个作用域决定了变量的生命周期，以及那一部分代码可以访问
  + 执行环境有全局和函数执行环境之分
  + 每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链
  + 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问包含其的（也叫父）环境，乃至全局环境；
  + 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据
  + 变量的执行环境有助于确定应该何时释放内存

+ javascript 有自动垃圾收集回收机制，
  + 离开作用域的值将被标记为可以回收，因此将在垃圾收集期间被删除
  + ‘标记清除’是目前主流的垃圾收集算法，这种算法的思想是给当前不用使用的值加标记，然后再回收其内存。
  + 另一种垃圾收集算法是‘引用计数’，这种算法的思想是跟踪记录所有值被引用的次数，目前这种算法不在使用
  + 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用全局对象、全局对象属性以及循环引用变量的引用

# 正则表达式

+ 元字符
+ 语法

## 元字符

+ .	点	
  + 查找单个字符除了换行和行结束符
+ \w  查找单词字符
+ \W  查找非单词字符
+ \d   数字
+ \D  非数字
+ \s   空白
+ \S  非空白
+ \b   匹配单词边界
+ \B  非单词边界
+ \0   NUL字符
+ \n   换行符
+ \f    换页符
+ \r    回车符
+ \t    制表符tab
+ \v   垂直制表符
+ \xxx    以八进制数 xxx 规定的字符
+ \xdd    以十六进制数 dd  规定的字符
+ \uxxxx   以十六进制  xxxx  规定的 Unicode 字符
+ 前缀添加  \x  表示用的是 ASCII 字符
+ 十六进制需要添加 \x   八进制不需要

## [  方括号表示字符范围 ] 

+ [abc]   查找括号内任意字符
+ [^abc]   不在括号内的字符        ^ 反义
+ [0-9]    0~9的数字
+ [a-z]     小写字母
+ [A-Z]     大写字母
+ [A-z]     大小写字母

+  |  表示或  `/\w+|\d+/`  任意字母或数字     

  + `/(abc)|(efg)|(123)|(456)/` 
  + 为了避免歧义，应该为选择操作的多个子模式加上小括号

## 重复匹配

+ { 大括号匹配数量 } 

  + `/go{3}/g  匹配3个 o`   `/go{3,5}/g  匹配3~5个o`
  + `/go*a/g  匹配所有`       `/go{1,}/g   最少一次最多无限`

+ |      **量词**       |                   **描述**                    |
  | :-----------------: | :-------------------------------------------: |
  |   n+        {1，}   |   匹配任何包含至少一个 n 的字符串  最多无限   |
  |   n*           *    |       匹配任何包含零个或多个 n 的字符串       |
  | n?          {0，1}  |       匹配任何包含零个或一个 n 的字符串       |
  |  n{x}         {3}   |        匹配包含 x 个 n 的序列的字符串         |
  | n{x,y}      {3，2}  | 匹配包含最少 x 个、最多 y 个 n 的序列的字符串 |
  | n{x,}         {3，} |      匹配包含至少 x 个 n 的序列的字符串       |

+ ```js
  var s = "ggle gogle google gooogle goooogle gooooogle goooooogle gooooooogle goooooooogle";
  仅匹配单词 ggle 和 gogle
  var r = /go?gle/g;    同等于 /go{0,1}gle/g;
  var a = s.match(r)
  ```

## **贪婪匹配和惰性匹配**

+ 重复类量词都具有贪婪性，在条件允许的前提下，会匹配尽可能多的字符
  + ?、{n} 和 {n,m} 重复类具有弱贪婪性，表现为贪婪的有限性。
  + *、+ 和 {n,} 重复类具有强贪婪性，表现为贪婪的无限性。
+ 惰性
+ {n,m}?：尽量匹配 n 次，但是为了满足限定条件也可能最多重复 m 次。
+ {n}?：尽量匹配 n 次。
+ {n,}?：尽量匹配 n 次，但是为了满足限定条件也可能匹配任意次。
+ ??：尽量匹配，但是为了满足限定条件也可能最多匹配 1 次，相当于 {0,1}?。
+ +?：尽量匹配 1 次，但是为了满足限定条件也可能匹配任意次，相当于 {1,}?。
+ *? ：尽量不匹配，但是为了满足限定条件也可能匹配任意次，相当于 {0,}?。

```js
越是排在左侧的重复类量词匹配优先级越高。下面示例显示当多个重复类量词同时满足条件时，会在保证右侧重复类量词最低匹配次数基础上，使最左侧的重复类量词尽可能占有所有字符。
var s = "<html><head><title></title></head><body></body></html>";
var r = /(<.*>)(<.*>)/;			/<.*?>/; //返回单个元素数组["<html>"]
var a = s.match(r);
//左侧表达式匹配"<html><head><title></title></head><body></body></html>"
console.log(a);
console.log(a[1]);  //<html><head><title></title></head><body></body>
console.log(a[2]);  //右侧表达式匹配“</html>”
```

## 边界量词

+   ^  匹配开头，在多行检测中，会匹配一行的开头
+   $  匹配结尾，在多行检测中，会匹配一行的结尾

```js
var s = "how are you";
var r = /\w+$/;
var a = s.match(r);  //返回数组["you"]
var r = /^\w+/;
var a = s.match(r);  //返回数组["how"]
var r = /\w+/g;
var a = s.match(r);  //返回数组["how","are","you"]
```

## 声明词量

+ 正向声明

  + 指定匹配模式后面的字符必须被匹配，但又不返回这些字符。语法格式如下

    + `匹配模式  (?= 匹配条件)    ?=n`     匹配任何其后紧接指定字符串 n 的字符串。

  + ```js
    var s = "one : 1; two : 2";
    var r = /\w*(?= : 2)/;  //使用正前向声明，指定执行匹配必须满足的条件
    var a = s.match(r);  //返回数组["two"]
    ```

+ 反向声明

  + 与正向声明匹配相反，指定接下来的字符都不必被匹配。语法格式如下：

  + `匹配模式  (?! 匹配条件)    ?!n`    匹配任何其后没有紧接指定字符串 n 的字符串。

  + ```js
    var s = "one : 1; two : 2";
    var r = /\w*(?! : 2)/;  //使用正前向声明，指定执行匹配必须满足的条件
    var a = s.match(r);  //返回数组["one"]
    console.log(a);
    ```

## 子表达式

+ 使用小括号可以对字符模式进行任意分组，在小括号内的字符串表示子表达式，也称为子模式。子表达式具有独立的匹配功能，保存独立的匹配结果；同时，小括号后的量词将会作用于整个子表达式。

```js
var s = "ab=21, bc=45, cd=43";
var r = /(\w+)=(\d*)/g;
while (a = r.exec(s)) {
    console.log(a);  //返回类似["ab=21","bc=45","cd=43"]三个数组
}

var s = "abcdefghijklmn";
var r = /(\w+)(\w)(\w)/;
r.test(s);
console.log(RegExp.$1);  //返回第1个子表达式匹配的字符abcdefghijkl
console.log(RegExp.$2);  //返回第2个子表达式匹配的字符m
console.log(RegExp.$3);  //返回第3个子表达式匹配的字符n

var s = "aa11bb22c3  d4e5f6";
var r = /(\w+?)(\d+)/g;
var b = s.replace(r,"$2$1");//更换子表达式的顺序， 可以改变字符串的顺序
console.log(b);  //返回字符串"11aa22bb3c  4d5e6f"

var s = "abc";
var r = /(a(b(c)))/;
var a = s.match(r);  //返回数组["abc","abc","bc","c"]
```



## 反向引用

+ `\+ 数字` 

+ 数字指定了子表达式在字符模式中的顺序。如“\1”引用的是第 1 个子表达式，“\2”引用的是第 2 个子表达式

+ ```js
  var s = "<h1>title</h1><p>text</p>";
  var r = /((<\/?\w+>).*(<\/?\w+>))/g;
  var a = s.match(r);  //返回数组["<h1>title</h1>","<p>text</p>"]
  ```

  

## 禁止引用

+ ```js
  var s1 = "abc";
  var r = /(?:\w*?)|(?:\d*?)/;  在左括号的后面加上一个问号和冒号。
  ```

  








```js
/[\u0000-\u00ff]/g		匹配任意 ASCII 字符
/[^\u0000-\u00ff]/g		匹配任意双字节的汉字
/[a-zA-Z0-9]/g			匹配任意大小写字母和数字
/[\u0030-\u0039]/g		使用 Unicode 编码设计，匹配数字
/[\u0041-\u004A]/g		匹配任意大写字母
[\u0061-\u007A]/g 		匹配任意小写字母
 
var s = "abcdez";  //字符串直接量
var r = /[abce-z]/g;  //字符a、b、c，以及从e~z之间的任意字符
var a = s.match(r);  //返回数组["a","b","c","e","z"]

var s = "abc4 abd6 abe3 abf1 abg7";  //字符串直接量
var r = /ab[c-g][1-7]/g;  //前两个字符为ab，第三个字符为从c到g，第四个字符为1~7的任意数字
var a = s.match(r);  //返回数组["abc4","abd6","abe3","abf1","abg7"]

var r = /[^0123456789]/g;  使用反义字符范围可以匹配很多无法直接描述的字符，达到以少应多的目的。

var s = '<meta charset="utf-8">';  //待过滤的表单提交信息
var r = /\'|\"|\<|\>/gi;  //过滤敏感字符的正则表达式
function f(a) {  //替换函数
    ////把敏感字符替换为对应的网页显示的编码格式
    return "&#" + arguments[0].charCodeAt(0) + ";";
    return "&#" + a.charCodeAt(0) + ";";
}
var a =s.replace(r,f);  //执行过滤替换 
// document.write(a);  //在网页中显示正常的字符信息
console.log(a);   // &#60;meta charset=&#34;utf-8&#34;&#62;
```