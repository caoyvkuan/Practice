# 响应式布局

## head

+ ```css
  <meta name="viewport" content="width=device-width"> 
  按照设备宽度来渲染页面内容
  
  <meta name="viewport" content="initial-scale=2.0,width=device-width"/> 
  content:
  initial-scale=2.0	把内容放大为实际的两倍大小
  width=device-width	页面宽度等于设备宽度
  maximum-scale=3	允许用户将页面放大到设备宽度的三倍
  minimun-scale=0.5	最小可将页面缩小至设备宽度的一半
  user-scalable=no	禁止用户缩放
  
  <meat name="viewport" content="width=device-width,initial-scale=1">
  大多数情况都可以使用这个
  
  使用max-width:100%;而不使用width:100%;
  有利于元素考虑之身宽度不被拉伸
  ```

## 媒体查询

+ ```css
  @media screen and (min-width: 50em){
      /*	@media 指令高数浏览器这是一个媒体查询
      	screen 告诉浏览器这里的规则只适用于屏幕类型
      	而and(min-width) 这其中的规则只适用于50em以上的情况	*/
  }
  
  在CSS2中
  <link rel="style sheet" type="text/css" media="screen" href="screenstyles. css">
  /*	不仅仅可以判断屏幕类型还能区分屏幕是否是垂直方向	*/
  <link rel="stylesheet" media="screen and (orientation: portrait)" href="portrait-screen.css" />
  
  <link rel="stylesheet" media="screen and (orientation: portrait) and 
  (min-width: 800px)" href="800wide-portrait-screen.css" /> 
  
  media="screen and (orientation: portrait) and(min-width: 800px),projection"
  projection后不接条件表示支持具备任何特性的该媒体类型,适配所有投影机
  ```

+ ```css
  @import url("phone.css") screen and (max-width:360px);
  屏幕设备视口不超过360px
  在css中使用@import会增加HTTP请求(影响加载速度)
      
  媒体查询可用特性
      width：视口宽度。
      height：视口高度。
      device-width：渲染表面的宽度（可以认为是设备屏幕的宽度）。
       device-height：渲染表面的高度（可以认为是设备屏幕的高度）。
       orientation：设备方向是水平还是垂直。
       aspect-ratio：视口的宽高比。16∶9的宽屏显示器可以写成aspect-ratio:16/9。
       color：颜色组分的位深。比如min-color:16表示设备至少支持16位深。
       color-index：设备颜色查找表中的条目数，值必须是数值，且不能为负。
       monochrome：单色帧缓冲中表示每个像素的位数，值必须是数值（整数），比如monochrome: 2，且不能为负。
       resolution：屏幕或打印分辨率，比如min-resolution: 300dpi。也可以接受每厘米多少点，比如min-resolution: 118dpcm。
       scan：针对电视的逐行扫描（progressive）和隔行扫描（interlace）。例如720p HD TV（720p中的p表示progressive，即逐行）可以使用scan: progressive来判断； 而1080i HD TV（1080i中的i表示interlace，即隔行）可以使用scan: interlace来判断。
       grid：设备基于栅格还是位图
      除scan和grid都可以加上min或max
      
      @media (scripting: enabled){
          /*	该属性暂时不支持	基本也不会支持了
          可以检测在有无javascript环境下的样式	*/
  	}
      
      在CSS4中以下属性已废除
      device-aspect-ratio
      device-height、
      device-width
  ```

#### 交互媒体特性

+ ```css
  指针特性有三个值:none、coarse、fine	coarse 指针设备代表手指触屏	fine	鼠标或其他精确的指针设备
  @media (pointer: coarse){
      /* 针对coarse指针的样式 */
  }
  
  /*	可悬停用 hover	可以悬停但需要步骤开启		on-demand	*/
  @media (hover: none){/*		悬停特性	*/}
  
  ```

#### 环境媒体特性

+ ```css
  @media (light-level: normal) { 
   /* 针对标准亮度的样式 */ 
  } 
  @media (light-level: dim) { 
   /* 针对暗光线条件的样式 */ 
  } 
  @media (light-level: washed) { 
   /* 针对强光线条件的样式 */ 
  }
  ```

## 弹性布局与响应式图片

+ 将固定的像素大小转换为弹性比例

  + 结果 = 目标/上下文

  + ```css
    一个布局宽度为960px的三栏布局
    左侧栏200px	中间区域660px		右侧栏100px
    那么左侧栏就=200/960	也就是20.83%
    中间区域=	660/960		68.75%
    右边	=	 100/960	10.41%
    ```

+ 行内块与空白

  + 使用行内块（inline-block）来布局的最大问题，就是它会在HTML元素间渲染空白。这不是bug

+ 表格与单元格

  + 别把display:table和display:table-cell与对应的HTML元素搞混！
  + CSS表格布局的很多实用之处。比如，跨平台绝对一致，而且能做到一个元素在另一个元素内垂直居中
  + 也不可能把设置为display:table-cell的项目包到多行上

#### Flexbox

+ Flexbox有4个关键特性: 方向 、对齐 、次序和弹性

+ ```Css
  overflow-wrap: break-word;	解决文本不会换行问题
  		方向			是否换行 
  flex-flow: flex-direction flex-wrap;
  flex-flow: row wrap; ==> flex-direction:row;	flex-wrap:wrap;
  justify-items
  
  
  justify-content(主轴对齐属性)		justify-self(网格属性可用)
      flex-start		flex-end		center
      space-between		spacr-around
  
  ```

 align-items(交叉轴对齐属性) 	     align-self		子元素单独决定对齐方式
      属性	flex-start	flex-end	center	
      baseline(所有项沿基准线对齐)	
      stretch(拉伸至父元素一样大)

  子项的flex属性	flex: 1(伸展)  1(收缩)	100px(基准);
  由三个结合flex-grow、flex-shrink、flex-basis

  flex-grow（传给flex的第一个值）是相对于其他伸缩项，当前伸缩项在空间允许的情
  况下可以伸展的量。
  flex-shrink是在空间不够的情况下，当前伸缩项相对于其他伸缩项可以收缩的量
  flex-basis（传给flex的最后一个值）是伸缩项伸缩的基准值。

  order可改变排列次序
  order:-1;就是要排在最前面
  其他改变需要给每个元素增加排列序号
  ```
  

#### 响应式图片

+ ```css
  通过srcset切换分辨率
  <img src="scones_small.jpg" srcset="scones_medium.jpg 1.5x, scones_ large.jpg 2x" alt="Scones taste amazing">
  不过有个问题。1440像素宽、1x的屏幕会拿到跟480像素宽、3x的屏幕相同的图片。这或许
  并不是我们想要的结果。
  
  srcset 及 sizes联合切换
  <img srcset="scones-small.jpg 450w, scones-medium.jpg 900w" sizes="(min-width: 17em) 100vw, (min-width: 40em) 50vw" src="sconessmall. jpg" alt="Scones">
  后缀W告诉浏览器图片有多宽 : 450px	但这里以w为后缀的值并不是“真实”大小，它只是对浏览器的一个提示，大致等于图片的“CSS像素”大小。
  
  picture元素
  
  <picture> /*	按照屏幕大小切换图片	*/
   <source media="(min-width: 30em)" srcset="cake-table.jpg"> 
   <source media="(min-width: 60em)" srcset="cake-shop.jpg"> 
   <img src="scones.jpg" alt="One way or another, you WILL get cake."> 
  </picture> 
  
  <picture> /*这里把WebP指定为优先使用的图片格式。
  			浏览器如果能显示，就显示，如果不能，就使用img标签里的图片。	*/
   <source type="image/webp" srcset="scones-baby-yeah.webp"> 
   <img src="scones-baby-yeah.jpg" alt="Again, you WILL eat cake."> 
  </picture> 
  ```

## HTML5

+ **<section>**元素

  + section元素用于定义文档或应用中一个通用的区块。例如，可以用section包装联系信息、新闻源，等等
  + 一般会用section包装可见组件。这样可以清楚地知道一个组件的开始和结束

+ **<nav>**元素

  + -<nav>元素用于包装指向其他页面或同一页面中不同部分的主导航链接
  + 如果你通常使用无序列表（<ul>）和列表标签（<li>）来写导航，那最好改成用nav嵌套多个a标签

+ **<article>**元素

  + -<article>用于包含一个独立的内容块。

  + 明显可以放到article元素中的内容有博客正文和新闻报道
  + 对于嵌套<article>而言，内部的<article>应该与外部<article>相关

+ **<aside>**元素

  + **<aside>**元素用于包含与其旁边内容不相关的内容
  + 包装侧边栏
  + 这个元素也适合包装突出引用、广告和导航元素
  + 基本上任何与主内容无直接关系的，都可以放在这里边

+ **<figure>**和**<figcaption>**元素

  + 如果图片或代码需要一个小标题，那么这个元素非常合适

+ **<detail>**和**<summary>**元素

  + ```HTML
    <!--	展开收起的摘要部件	-->
    <details> 	<!--	显示的摘要	-->
     <summary>I ate 15 scones in one day</summary> 
     <p>Of course I didn't. It would probably kill me if I did. What a 
    way to go. Mmmmmm, scones!</p> 
    </details>
    <!--	禁用部件的默认样式	-->
    summary::-webkit-details-marker { 
     display: none; 
    } 
    ```

+ **<header>**元素

  + 在<article>元素中用作某个区块的引介区。它可以在一个页面中出现多次
  + 比如页面中每个<sectioin>中都可以有一个<header>

+ **<footer>**元素同<header>一样

+ **<address>**元素

  + *<address>*元素明显用于标记联系人信息，为最接近的<article>或<body>所用
  + 不过有一点不好理解，它并不是为包含邮政地址准备的（除非该地址确实是相关内容的联系地址）。邮政地址以及其他联系信息应该放在传统的<p>标签里。

+ **h1** 到 **h6**

  + h1到h6元素不能用于标记副标题、字幕、广告语，除非想把它们用作新区块或子区块的标题

#### HTML5 文本级元素

+ **<b>**元素不能用它来包围一大段其他标记
+ *<em>*em元素表示内容中需要强调的部分
+ **<i>**元素    它不仅仅用于把文本标为斜体。比如，可以用它在文本中标记出罕用的名字：

#### 作废的html特性

+ 主要包括：strike、center、font、acronym、frame和frameset

#### 响应式HTML5视频与内嵌框架

+ video { max-width: 100%; height: auto; } 

+ 内嵌框架

  + ```html
    <style>.embed-container { position: relative; padding-bottom: 56.25%; 
    height: 0; overflow: hidden; max-width: 100%; height: auto; } .embedcontainer 
    iframe, .embed-container object, .embed-container embed { 
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</ 
    style><div class='embed-container'><iframe src='http://www.youtube. com/embed/B1_N28DA3gY' frameborder='0' allowfullscreen></iframe></div> 
    ```

## CSS 新特性

+ 多列布局

  + ```css
     改变viewport宽度会动态改变列数
    column-width: 12em;
    
    固定列数可变宽度
    column-count: 4;
    
    分割线
    column-gap: 2em; 
    column-rule: thin dotted #999; 
    ```

+ 断字

  + word-wrap: break-word; 

+ 截短文本

  + ```css
    overflow: hidden;
    text-overflow: ellipsis; 
    white-space: no-wrap; 
    ```

+ 平面滚动面板

  + ```css
    .Scroll_Wrapper { 
        width: 100%; 
        white-space: nowrap; 
        overflow-x: auto; 
        overflow-y: hidden; 
        /* 在WebKiet的触摸设备上出现 */ 
        -webkit-overflow-scrolling: touch; 
        /* 在支持的IE中删除滚动条 */ 
        -ms-overflow-style: none; 
    } ]
    /* 防止WebKit浏览器中出现滚动条 */ 
    .Scroll_Wrapper::-webkit-scrollbar { 
        display: none; 
    }
    .Item { 
        display: inline-flex; 
    }/* 防止WebKit浏览器中出现滚动条 */ 
    .Scroll_Wrapper::-webkit-scrollbar { 
     display: none; 
    }
    ```

  #### 特性查询

  + ```css
    @supports (flashing-sausages: lincolnshire) { 
        body { 
            sausage-sound: sizzling; 
            sausage-color: slighty-burnt; 
            background-color: brown; 
        } 
    } 
    这段样式只有浏览器支持flashing-sausages属性才会应用。我肯定没有浏览器打算支持这个属性，因此@supports块中的样式不会被应用
        
        
    @supports ((display: flex) and (pointer:coarse)){   
       .Item { 
          display: inline-flex; 
       } 
    } 
    @supports not (display: flex) { 
       .Item { 
           display: inline-block; 
       } 
    } 
    
    还能用js检查特性	Modernizr脚本
    来创建CSS分支
    ```

#### CSS3选择符

+ ```css
  属性选中符
  img[alt]
  img[alt="sausages"]
  
  1. 以……开头
  img[alt^="film"]
  
  2. 包含……
  [attribute*="value"]
  
  3. 以……结尾
  [attribute$="value"]
  
  [data-film*="awful"][data-film*="moulin-rouge"]{}
  
  如果输入元素中的值是非法的
  input:invalid
  如果输入元素中输入的合法的
  input:valid
  ```

### CSS3结构化伪类

+ **:last-child**

+ **:first-child**

+ 针对只有一项的选择符**:only-child**和唯一一个当前标签的选择符**:only-of-type**

+ **:nth-child**

  + 隔一个选一个**:nth-child(odd)**

  + 偶数**:nth-child(even)**

  + ```css
     nth-child(n)
     nth-last-child(n)
     nth-of-type(n)
     nth-last-of-type(n)
    /*	从第三个开始每隔一个会选中一次	*/
    :nth-child(2n+3)
    :nth-child(-2n+3)	反方向选中
    
    .span-class:nth-of-type(-2n+3)
    虽然所有元素都有相同的类span-class，
    但这里只会选择带有该类的span元素（因为第一个选中的元素的类型是span）。
    
    /* 每4个选1个，但仅限于最后4项 */ 
    .Item:nth-child(4n+1):nth-last-child(-n+4), 
    /* 取得该集合后面的每一项 */ 
    .Item:nth-child(4n+1):nth-last-child(-n+4) ~ .Item
    ```

  + **:not**

    + `:not(.not-me)`	选中不包含(.not-me)

  + **:empty**

    + 选中空元素
    + 有空格不算空元素,只有注释算空元素

  + **::first-line**

    + 选中第一行

#### 自定义属性和变量

+ ```css
  自定义属性创建方法
  :root { 
   --MainFont: 'Helvetica Neue', Helvetica, Arial, sans-serif; 
  }
  引用
  .Title { 
   font-family: var(--MainFont); 
  } 
  
  const vh = document.documentElement.clientHeight;
  document.documentElement.style.setProperty('--view-height', vh+'px');
  操作自定义属性
  ```

+ 计算    `calc(50% - 20px)`

+ **:has**伪类

  + ```css
    暂时不能用
    a:has(figcaption) { 
     padding: 1rem; 
    } 
    这条规则可以给一个包含figcaption的a标签添加内边距。组合使用“取反”伪类，可以
    反转选择范围：
    a:not(:has(figcaption))
    ```

#### 字体

+ @font-face

  + ```CSS
    @font-face { 
        font-family: 'robotoregular'; 
        src: url('Roboto-Regular-webfont.eot'); 
        src: url('Roboto-Regular-webfont.eot?#iefix') format('embeddedopentype'), 
            url('Roboto-Regular-webfont.woff') format('woff'), 
            url('Roboto-Regular-webfont.ttf') format('truetype'), 
            url('Roboto-Regular-webfont.svg#robotoregular') 
            format('svg'); 
        font-weight: normal; 
        font-style: normal; 
    }
    与提供商前缀的机制很类似，浏览器也会依次尝试属性列表中的样式，忽略不能识别的内容
    （属性值越靠下，优先级越高）
    ```

## CSS 高级

+ 文字阴影特效

  + ```css
    text-shadow: -4px -4px 1px #ccc; 
    
    省略  blur  值
    text-shadow: -4px -4px #dad7d7;
    
    多阴影
    text-shadow: 0px 1px #fff,
    			4px 4px 0px #dad7d7;
    ```

+ 盒阴影

  + ```css
    box-shadow: 0px 3px 5px #444;
    
    内阴影
    box-shadow: inset 0 0 40px #000;
    同样可使用多重
    还能用负值
    ```

#### 背景渐变

+ ```css
  在渐变前添加前缀repeagting重复渐变效果	repeagting-linear-gradient()
  线性渐变					从不可见的位置就开始
  background: linear-gradient(red -50%, blue);
  方向	45deg
  background: linear-gradient(to top right, red, blue); 
  
  径向渐变	直径12rem的圆形渐变	circle会生成占满整个圆形容器的渐变效果
  设置为40px 30px会生成一个X方向宽为40像素、Y方向高为30像素的椭圆形
  设置为ellipse会生成和容器大小一致的椭圆形
  at top right表示径向渐变的中心在右上方
  at right 100px top 20px表示径向渐变的中心在距右边框100像素、上边框20像素处
  at center left表示径向渐变的中心在左边框中间处
  background: radial-gradient(12rem circle at bottom, yellow, orange, red); 
  
  为响应式而生的关键字
   closest-side：在渐变形状为圆形的情况下，渐变形状会与距离中心最近的边框相切；在椭圆形的情况下，则会与距离中心最近的两个边框相切。
   closest-corner：渐变形状会与距离中心最近的角相切。
   farthest-side：和closest-side相反。在圆形的情况下，与距离中心最远的边相切。在椭圆的情况下，与距离中心最远的两边相切。
   farthest-corner：渐变形状会与距离中心最远的角相切。
   cover：等价于farthest-corner。
   contain：等价于closest-side。
  ```

#### 渐变背景创建图案

+ ```css
  .carbon-fibre { 
   margin: 1rem; 
   width: 400px; 
   height: 200px; 
   background: 
   radial-gradient(black 15%, transparent 16%) 0 0, 
   radial-gradient(black 15%, transparent 16%) 8px 8px, 
   radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 0 1px, 
   radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 8px 
  9px; 
   background-color:#282828; 
   background-size:16px 16px; 
  } 
  ```

#### 背景堆叠

+ ```css
  优先级从上到下
  .bg { 		ie8	不支持
   background: 
   url('../img/1.png'), 
   url('../img/2.png'), 
   url('../img/3.png') left bottom, black; 
  } 
  
  背景大小	为每张背景图片设置大小
  background-size: 100% 50%, 300px 400px, auto;
   auto：让图片保持其原生大小。
   cover：保持图片比例，拓展至覆盖整个元素。
   contain：保持图片比例，拓展图片让其最长边保持在元素内部
  
  背景位置
  background-position: top 50px right 80px, 40px 40px, top center;
  
  在“正常”和高清屏幕选择不同分辨率图片
  .bg { 
   background-image: url('bg.jpg'); 
  } 
  /*	1.5dppx（设备像素与CSS像素比）	*/
  @media (min-resolution: 1.5dppx) { 
   .bg { 
  background-image: url('bg@1_5x.jpg'); 
   } 
  } 
  ```

#### 背景滤镜

+ ```css
  box-shadow	元素的阴影只能是矩形
  filter:drop-shadow(8px 8px 6px #333);	语法与box-shadow一样
  
   filter: url ('./img/filters.svg#filterRed')：首先定义一个SVG滤镜来使用。
   filter:blur(3px)：使用一个简单的长度值（不是百分比）。
   filter:brightness(2)：使用从0到1的值或者从0%到100%的值。0/0%意味着全黑，1/100%意味着正常没有变化，而任何更高的值意味着更高的亮度
   filter:contrast(2)：使用从0到1的值或者从0%到100%的值。0/0%意味着全黑1/100%意味着正常没有变化，而更高的值意味着更高的对比度
   filter:drop-shadow(4px 4px 6px #333)：
   filter:grayscale(.8)：使用从0到1或者从0%到100%的值来表示元素灰度化的程度。0表示没有灰度化，而1表示完全灰度化。
   filter:hue-rotate(25deg)：使用从0度到360度表示颜色在色轮上的变化角度。
   filter:invert(75%)：使用从0到1的值或者从0%到100%表示元素中反色的程度。
   filter:opacity(50%)：使用从0到1的值或者从0%到100%的值来改变元素的透明度。这和你熟悉的opacity属性是相似的。然而滤镜是可以多个同时使用的，这让透明效果可以和其他滤镜效果结合在一起
   filter:saturate(15%)：使用从0到1的值或者从0%到100%来表示图像的饱和度。高于1/100%的值会增加额外的饱和度。
   filter:sepia(.74)：使用从0到1的值或者从0%到100%来为元素添加褐色滤镜。0/0%表示元素没有变化，而更高的值则表示褐色化程度的提升，1/100%表示最高的效果。
  
  /*滤镜可用使用多个*/
  filter: opacity(10%) blur(2px) sepia(35%);
  ```

#### 性能

+ 括号外的决定了页面的架构，括号内的决定了页面的性能。
+ 属性增加的效果越多性能消耗越严重\

## SVG

+ SVG的根元素属性

  + width、height和viewbox属性

  + ```css
    viewbox属性可以让你缩放图片。例如：
    <svg width="198px" height="188px" viewBox="0 0 99 94" >
    那么其中的形状为了填满SVG的宽度和高度，就会被放大
    ```

+ 命名空间

  + ```css
    xmlns:sketch="http://www.bohemiancoding.com/sketch/ns"
    这些命名空间往往只是在生成SVG的程序中使用，
    所以在Web页面上展示SVG的时候它们并不是必需的。
    因此在优化流程中，为了减小SVG的大小，通常会把它们去掉
    ```

+ 标题和描述

  + ```xml
    <title>Star 1</title> 
     <desc>Created with Sketch.</desc> 
    当SVG图片被应用为背景图片的时候，可以去除这些标签来减小文件大小
    ```

+ defs 标签

  + 用于储存所有可以复用的元素定义的地方，如梯度、符号、路径等.

+ 元素 g

  + ```html
    g元素能把其他元素捆绑在一起
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fillrule=" 
    evenodd" sketch:type="MSPage"> 
    在g标签中可以看到先前的命名空间。这会有助于图形编辑软件再次打开这个图像，但
    是它对于这个图片在其他地方展示并没有影响
    ```

+ SVG形状元素

  + ```HTML
    <polygon id="Star-1" stroke="#979797" stroke-width="3" fill="#F8E81C" 
    sketch:type="MSShapeGroup" points="99 154 40.2214748 184.901699 
    51.4471742 119.45085 3.89434837 73.0983006 69.6107374 63.5491503 99 
    4 128.389263 63.5491503 194.105652 73.0983006 146.552826 119.45085 
    157.778525 184.901699 "></polygon> 
    
    SVG拥有一系列可用的现成形状（path、rect、circle、ellipse、line、polyline、polygon）。
    ```

+ svg路径

  + SVG路径和其他SVG形状有所区别，因为它们是由任意数量的连接点组成的

#### 在Web页面中插入svg

+ 使用img标签

  + ```HTML
    <img src="mySconeVector.svg" alt="Amazing line art of a scone" />
    ```

+ 使用object标签

  + ```HTML
    <object data="img/svgfile.svg" type="image/svg+xml"> 
        <span class="fallback-info">Your browser doesn't support SVG</span> 
    </object> 
    data URI可以节省网络请求
    ```

+ 把 SVG 作为背景图像插入

  + ```css
    background-image: url('image.svg');
    ```

+ 内联svg

+ ```html
  <svg id="svgInline" width="198" height="188" viewBox="0 0 198 188" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> 
      <title>Star 1</title> 
      <g class="star_Wrapper" fill="none" fill-rule="evenodd"> 
          <path id="star_Path" stroke="#979797" strokewidth="3" fill="#F8E81C" d="M99 154l-58.78 30.902 11.227-65.45L3.894 73.097l65.717-9.55L99 4l29.39 59.55 65.716 9.548-47.553 46.353 11.22665.452z" /> </g> 
  </svg>
  删除掉svg元素的width和height属性，SVG就会自动缩放来填满容器
  ```

## CSS3过度、变形、动画

+ 过度

  + ```css
     transition-property ：要过渡的 CSS 属性的名字（如 background-color 、text-shadow或者all，all会过渡所有可以过渡的属性）。
    
     transition-duration：定义过渡效果持续的时长（用秒进行定义，例如.3s、2s或1.5s）。
    
     transition-timing-function：定义过渡期间的速度变化（例如ease、linear、ease-in、ease-out、ease-in-out或者cubic-bezier）。
    
     transition-delay：可选，用于定义过渡开始前的延迟时间。相反，将值设置为一个负数，可以让过渡效果立即开始，但过渡旅程会在半路结束。同样是用秒进行定义，例如.3s、2s或2.5s。
    ```

  + ```css
    在不同的时间段内过度不同的属性
    transition-property: border, color, text-shadow; 
    transition-duration: 2s, 3s, 8s; 
    
    * {/*	有趣?	*/
     transition: all 1s; 
    } 
    ```

#### CSS的2d变形

+ transformation

  + transform

  + ```css
     scale：用来缩放元素（放大和缩小）	scale(1.4)	1.4倍
     translate：在屏幕上移动元素（上下左右）	translate(-50%, -50%); 
     rotate：按照一定角度旋转元素（单位为度）	rotate(30deg);
     skew：沿X和Y轴对元素进行斜切		skew(40deg(X), 12deg(Y))
     matrix：允许你以像素精度来控制变形效果
    matrix(1.678, -0.256, 1.522, 2.333, -51.533, -1.989)
    
    transform-origin 属性
    使用transform-origin，可以修改变形原点。
    ```

#### 3D变形

+ ```css
  transition: transform 1s; 
  transform-style: preserve-3d; 这告诉浏览器，当我们要为这个元素创造变形效果时，它的子元素也保持3D效果
  
  transform: rotateX(180deg) translate3d(0, 0, -120px);/*	translate3d(X, Y, Z)	*/
  ```

#### 动画

+ ```css
  animation: pulse 1s 1s infinite alternate both;
  此时的animation属性使用了缩写语法。在本例中，我们实际定义了（依照定义顺序）使用
  的关键帧规则的名字（pulse）、动画持续时长（1s）、动画开始延迟（1s，给予按钮足够的时长
  用于翻转）、动画运行的次数（infinite，无限次）、动画播放方向（alternate，交替，所以
  动画轮流往复地播放），最后我们想让animation-fill-mode保留动画中无论是顺序播放还是
  倒序播放后的值（both）
  
  animation-name: warning; 
  animation-duration: 1.5s; 
  animation-timing-function: ease-in-out; 
  animation-iteration-count: infinite; 
  animation-play-state: running | paused; 
  animation-delay: 0s; 
  animation-fill-mode: none | forwards | backwards | both; 
  animation-direction: normal | reverse | alternate | alternatereverse; 
  ```

## 表单

+ **placeholder**属性

  + ```CSs
    可以用placeholder-shown伪类选择器来为placeholder属性添加样式
    input:placeholder-shown { 
        color: #333; 
    } 
    ```

+ **required**属性

  + 添加required属性表述必填项
  + range、color、button和hidden类型的输入元素不能使用required,因为这几种输入类型几
    乎都有默认值

+ **autofocus**属性

  + 页面加载时默认选中
  + 使用autofocus属性的时候，要确保只在表单中使用一次，并且了解对那些使用空格滚动的用户的影响

+ **autocomplete**属性

  + 禁用自动补全	on	||	off

+ **list** 及对应的 **datalist** 元素

  + 给list属性值为datalist元素id的输入框候选列表

#### 输入类型

+ ```html
  大多数输入类型都会优化移动设备输入键盘的默认显示
  type="email"
  
  type="number"
  限制范围
  type="number" min="1929" max="2015"
  改变步长
  <input type="number" step="10"> 
  
  type="url"
  type="tel"
  type="search" 	普通文本类型
  patter=""		正则表达式限制
  type="color"
  type="date"		type="month"		type="week"		type="time"
  <input type="range" min="1" max="10" value="5">	滑动条	初始值5
  ```

#### 使用CSS美化表单

+ 显示必填项

  + `input:required{}`

  + 可以设定输入域上的border或者outline

  + `input:focus:required{}`

  + ```css
    如果输入元素中的值是非法的
    input:invalid
    如果输入元素中输入的合法的
    input:valid
    ```

## 响应式

+ 首先为最小的视口编写CSS，然后在媒体查询中修改其在较大视口下的表现 ==> 比较轻松

+ 在真实设备上观察和使用设计

+ 拥抱渐进增强

  + 从选择支持的浏览器中选取它们共有的子集方法来开始编写你的前端代码（HTML、CSS、JavaScript）
  + 然后，逐步优化你的代码以适应那些比较强大的浏览器和设备

+ 应专注于正确使用main、header、footer、article、section和aside等元素。

+ 确定需要支持的浏览器

+ 等价的功能，而不是等价的外观

+ 将 CSS 断点与 JavaScript 联系起来

  + 通常，一些页面上的交互都会涉及JavaScript。当你在开发响应式项目的时候，可能想在不同尺寸的视口里看到不同的效果。这既包括CSS也包括JavaScript。

  + ```css
    利用伪元素让javascript识别CSS断点
    
    var size = window.getComputedStyle(document.body,':after').getPropertyValue('content');
    (function alertSize() { 
        if (size.indexOf("Splus") !=-1) { 
            alert('I will run functions for small screens'); 
        } 
        if (size.indexOf("Mplus") !=-1) { 
            alert('At medium sizes, a different function could run'); 
        } 
        if (size.indexOf("Lplus") !=-1) { 
            alert('Large screen here, different functions if needed'); 
        } 
    })(); 
    
    @media (min-width: 20rem) { 
        body::after { 
            content: "Splus"; 
            font-size: 0; 
        } 
    } 
    @media (min-width: 47.5rem) { 
        body::after { 
            content: "Mplus"; 
            font-size: 0; 
        } 
    } 
    @media (min-width: 62.5rem) { 
        body::after { 
            content: "Lplus"; 
            font-size: 0; 
        } 
    }
    ```

+ 在开发中避免使用框架

+ 尽可能使用最简单的代码

  + 例如，如果你需要为列表中的第五个元素添加不同的样式，并且你能操作标记，那就不要像下面这样使用nth-child选择器

  + ```css
    .list-item:nth-child(5) { 
     /* 样式 */ 
    } 
    
    应该提倡这种方式
    <li class="list-item specific-class">Item</li> 
    然后使用类来添加样式：
    .specific-class { 
     /* 样式 */ 
    } 
    ```

+ 根据视口隐藏、展示和加载内容

  + 响应式Web设计中有一个常用的准则：如果你在小屏幕上不加载某一部分，那么在大屏幕上也不应该加载

+ 将复杂的可视化工作交给 CSS

+ 验证器和代码检测工具

+ 性能

  + 减少你的资源数（例如，不要加载15个JavaScript文件，而应该将它们拼成一个）。
  + 减小你的页面大小（如果你能压缩图片，那么请压缩）
  + 延迟加载非必需资源（如果你可以将CSS和JavaScript的加载延迟到页面加载完成后，就可以大幅缩短初始化时间）
  + 保证页面尽快可用（通常是上述所有步骤的副产物）
  + 当你尝试优化性能时，确保在开始前衡量性能表现（否则，你不知道你的优化工作的成果）。然后调整、测试，再重复上述步骤。

+ 延迟加载

  + ```html
    <script>
        setTimeout(function(){
            document.getElementById("img2").setAttribute("src","gq2.jpeg");
            downLoadJs("jquery.js");
            downLoadCss("styles.css");
        },1000);
     
        function downLoadJs(url){
            var elem = document.createElement("script");
            elem.src = url;
            document.body.appendChild(elem);
        }
     
        function downLoadCss(url){
            var elem = document.createElement("link");
            elem.rel = "stylesheet";
            elem.type = "text/css";
            elem.href = url;
            document.body.appendChild(elem);
        }
    </script>
    ```

    

