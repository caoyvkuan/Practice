# 响应式布局

## head

+ ```css
  <meta name="viewport" content="width=device-width"> 
  按照设备宽度来渲染页面内容
  
  <meta name="viewport" content="initial-scale=2.0,width=device-width"/> 
  content:
  initial-scale=2.0	把内容放大为实际的两倍大小
  width=device-width	页面宽度等于设备宽度
  maximum-scale=3	允许用户将页面放大到设备宽度的三倍
  minimun-scale=0.5	最小可将页面缩小至设备宽度的一半
  user-scalable=no	禁止用户缩放
  
  <meat name="viewport" content="width=device-width,initial-scale=1">
  大多数情况都可以使用这个
  
  使用max-width:100%;而不使用width:100%;
  有利于元素考虑之身宽度不被拉伸
  ```

## 媒体查询

+ ```css
  @media screen and (min-width: 50em){
      /*	@media 指令高数浏览器这是一个媒体查询
      	screen 告诉浏览器这里的规则只适用于屏幕类型
      	而and(min-width) 这其中的规则只适用于50em以上的情况	*/
  }
  
  在CSS2中
  <link rel="style sheet" type="text/css" media="screen" href="screenstyles. css">
  /*	不仅仅可以判断屏幕类型还能区分屏幕是否是垂直方向	*/
  <link rel="stylesheet" media="screen and (orientation: portrait)" href="portrait-screen.css" />
  
  <link rel="stylesheet" media="screen and (orientation: portrait) and 
  (min-width: 800px)" href="800wide-portrait-screen.css" /> 
  
  media="screen and (orientation: portrait) and(min-width: 800px),projection"
  projection后不接条件表示支持具备任何特性的该媒体类型,适配所有投影机
  ```

+ ```css
  @import url("phone.css") screen and (max-width:360px);
  屏幕设备视口不超过360px
  在css中使用@import会增加HTTP请求(影响加载速度)
      
  媒体查询可用特性
      width：视口宽度。
      height：视口高度。
      device-width：渲染表面的宽度（可以认为是设备屏幕的宽度）。
       device-height：渲染表面的高度（可以认为是设备屏幕的高度）。
       orientation：设备方向是水平还是垂直。
       aspect-ratio：视口的宽高比。16∶9的宽屏显示器可以写成aspect-ratio:16/9。
       color：颜色组分的位深。比如min-color:16表示设备至少支持16位深。
       color-index：设备颜色查找表中的条目数，值必须是数值，且不能为负。
       monochrome：单色帧缓冲中表示每个像素的位数，值必须是数值（整数），比如monochrome: 2，且不能为负。
       resolution：屏幕或打印分辨率，比如min-resolution: 300dpi。也可以接受每厘米多少点，比如min-resolution: 118dpcm。
       scan：针对电视的逐行扫描（progressive）和隔行扫描（interlace）。例如720p HD TV（720p中的p表示progressive，即逐行）可以使用scan: progressive来判断； 而1080i HD TV（1080i中的i表示interlace，即隔行）可以使用scan: interlace来判断。
       grid：设备基于栅格还是位图
      除scan和grid都可以加上min或max
      
      @media (scripting: enabled){
          /*	该属性暂时不支持	基本也不会支持了
          可以检测在有无javascript环境下的样式	*/
  	}
      
      在CSS4中以下属性已废除
      device-aspect-ratio
      device-height、
      device-width
  ```

#### 交互媒体特性

+ ```css
  指针特性有三个值:none、coarse、fine	coarse 指针设备代表手指触屏	fine	鼠标或其他精确的指针设备
  @media (pointer: coarse){
      /* 针对coarse指针的样式 */
  }
  
  /*	可悬停用 hover	可以悬停但需要步骤开启		on-demand	*/
  @media (hover: none){/*		悬停特性	*/}
  
  ```

#### 环境媒体特性

+ ```css
  @media (light-level: normal) { 
   /* 针对标准亮度的样式 */ 
  } 
  @media (light-level: dim) { 
   /* 针对暗光线条件的样式 */ 
  } 
  @media (light-level: washed) { 
   /* 针对强光线条件的样式 */ 
  }
  ```

## 弹性布局与响应式图片

+ 将固定的像素大小转换为弹性比例

  + 结果 = 目标/上下文

  + ```css
    一个布局宽度为960px的三栏布局
    左侧栏200px	中间区域660px		右侧栏100px
    那么左侧栏就=200/960	也就是20.83%
    中间区域=	660/960		68.75%
    右边	=	 100/960	10.41%
    ```

+ 行内块与空白

  + 使用行内块（inline-block）来布局的最大问题，就是它会在HTML元素间渲染空白。这不是bug

+ 表格与单元格

  + 别把display:table和display:table-cell与对应的HTML元素搞混！
  + CSS表格布局的很多实用之处。比如，跨平台绝对一致，而且能做到一个元素在另一个元素内垂直居中
  + 也不可能把设置为display:table-cell的项目包到多行上

#### Flexbox

+ Flexbox有4个关键特性: 方向 、对齐 、次序和弹性

+ ```Css
  overflow-wrap: break-word;	解决文本不会换行问题
  		方向			是否换行 
  flex-flow: flex-direction flex-wrap;
  flex-flow: row wrap; ==> flex-direction:row;	flex-wrap:wrap;
  justify-items
  
  
  justify-content(主轴对齐属性)		justify-self(网格属性可用)
      flex-start		flex-end		center
      space-between		spacr-around
  
  ```

 align-items(交叉轴对齐属性) 	     align-self		子元素单独决定对齐方式
      属性	flex-start	flex-end	center	
      baseline(所有项沿基准线对齐)	
      stretch(拉伸至父元素一样大)

  子项的flex属性	flex: 1(伸展)  1(收缩)	100px(基准);
  由三个结合flex-grow、flex-shrink、flex-basis

  flex-grow（传给flex的第一个值）是相对于其他伸缩项，当前伸缩项在空间允许的情
  况下可以伸展的量。
  flex-shrink是在空间不够的情况下，当前伸缩项相对于其他伸缩项可以收缩的量
  flex-basis（传给flex的最后一个值）是伸缩项伸缩的基准值。

  order可改变排列次序
  order:-1;就是要排在最前面
  其他改变需要给每个元素增加排列序号
  ```
  

#### 响应式图片

+ ```css
  通过srcset切换分辨率
  <img src="scones_small.jpg" srcset="scones_medium.jpg 1.5x, scones_ large.jpg 2x" alt="Scones taste amazing">
  不过有个问题。1440像素宽、1x的屏幕会拿到跟480像素宽、3x的屏幕相同的图片。这或许
  并不是我们想要的结果。
  
  srcset 及 sizes联合切换
  <img srcset="scones-small.jpg 450w, scones-medium.jpg 900w" sizes="(min-width: 17em) 100vw, (min-width: 40em) 50vw" src="sconessmall. jpg" alt="Scones">
  后缀W告诉浏览器图片有多宽 : 450px	但这里以w为后缀的值并不是“真实”大小，它只是对浏览器的一个提示，大致等于图片的“CSS像素”大小。
  
  picture元素
  
  <picture> /*	按照屏幕大小切换图片	*/
   <source media="(min-width: 30em)" srcset="cake-table.jpg"> 
   <source media="(min-width: 60em)" srcset="cake-shop.jpg"> 
   <img src="scones.jpg" alt="One way or another, you WILL get cake."> 
  </picture> 
  
  <picture> /*这里把WebP指定为优先使用的图片格式。
  			浏览器如果能显示，就显示，如果不能，就使用img标签里的图片。	*/
   <source type="image/webp" srcset="scones-baby-yeah.webp"> 
   <img src="scones-baby-yeah.jpg" alt="Again, you WILL eat cake."> 
  </picture> 
  ```

## HTML5

+ **<section>**元素

  + section元素用于定义文档或应用中一个通用的区块。例如，可以用section包装联系信息、新闻源，等等
  + 一般会用section包装可见组件。这样可以清楚地知道一个组件的开始和结束

+ **<nav>**元素

  + -<nav>元素用于包装指向其他页面或同一页面中不同部分的主导航链接
  + 如果你通常使用无序列表（<ul>）和列表标签（<li>）来写导航，那最好改成用nav嵌套多个a标签

+ **<article>**元素

  + -<article>用于包含一个独立的内容块。

  + 明显可以放到article元素中的内容有博客正文和新闻报道
  + 对于嵌套<article>而言，内部的<article>应该与外部<article>相关

+ **<aside>**元素

  + **<aside>**元素用于包含与其旁边内容不相关的内容
  + 包装侧边栏
  + 这个元素也适合包装突出引用、广告和导航元素
  + 基本上任何与主内容无直接关系的，都可以放在这里边

+ **<figure>**和**<figcaption>**元素

  + 如果图片或代码需要一个小标题，那么这个元素非常合适

+ **<detail>**和**<summary>**元素

  + ```HTML
    <!--	展开收起的摘要部件	-->
    <details> 	<!--	显示的摘要	-->
     <summary>I ate 15 scones in one day</summary> 
     <p>Of course I didn't. It would probably kill me if I did. What a 
    way to go. Mmmmmm, scones!</p> 
    </details>
    <!--	禁用部件的默认样式	-->
    summary::-webkit-details-marker { 
     display: none; 
    } 
    ```

+ **<header>**元素

  + 在<article>元素中用作某个区块的引介区。它可以在一个页面中出现多次
  + 比如页面中每个<sectioin>中都可以有一个<header>

+ **<footer>**元素同<header>一样

+ **<address>**元素

  + *<address>*元素明显用于标记联系人信息，为最接近的<article>或<body>所用
  + 不过有一点不好理解，它并不是为包含邮政地址准备的（除非该地址确实是相关内容的联系地址）。邮政地址以及其他联系信息应该放在传统的<p>标签里。

+ **h1** 到 **h6**

  + h1到h6元素不能用于标记副标题、字幕、广告语，除非想把它们用作新区块或子区块的标题

#### HTML5 文本级元素

+ **<b>**元素不能用它来包围一大段其他标记
+ *<em>*em元素表示内容中需要强调的部分
+ **<i>**元素    它不仅仅用于把文本标为斜体。比如，可以用它在文本中标记出罕用的名字：

#### 作废的html特性

+ 主要包括：strike、center、font、acronym、frame和frameset

#### 响应式HTML5视频与内嵌框架

+ video { max-width: 100%; height: auto; } 

+ 内嵌框架

  + ```html
    <style>.embed-container { position: relative; padding-bottom: 56.25%; 
    height: 0; overflow: hidden; max-width: 100%; height: auto; } .embedcontainer 
    iframe, .embed-container object, .embed-container embed { 
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</ 
    style><div class='embed-container'><iframe src='http://www.youtube. com/embed/B1_N28DA3gY' frameborder='0' allowfullscreen></iframe></div> 
    ```

## CSS 新特性

+ 多列布局

  + ```css
     改变viewport宽度会动态改变列数
    column-width: 12em;
    
    固定列数可变宽度
    column-count: 4;
    
    分割线
    column-gap: 2em; 
    column-rule: thin dotted #999; 
    ```

+ 断字

  + word-wrap: break-word; 

+ 截短文本

  + ```css
    overflow: hidden;
    text-overflow: ellipsis; 
    white-space: no-wrap; 
    ```

+ 平面滚动面板

  + ```css
    .Scroll_Wrapper { 
        width: 100%; 
        white-space: nowrap; 
        overflow-x: auto; 
        overflow-y: hidden; 
        /* 在WebKiet的触摸设备上出现 */ 
        -webkit-overflow-scrolling: touch; 
        /* 在支持的IE中删除滚动条 */ 
        -ms-overflow-style: none; 
    } ]
    /* 防止WebKit浏览器中出现滚动条 */ 
    .Scroll_Wrapper::-webkit-scrollbar { 
        display: none; 
    }
    .Item { 
        display: inline-flex; 
    }/* 防止WebKit浏览器中出现滚动条 */ 
    .Scroll_Wrapper::-webkit-scrollbar { 
     display: none; 
    }
    ```

  #### 特性查询

  + ```css
    @supports (flashing-sausages: lincolnshire) { 
        body { 
            sausage-sound: sizzling; 
            sausage-color: slighty-burnt; 
            background-color: brown; 
        } 
    } 
    这段样式只有浏览器支持flashing-sausages属性才会应用。我肯定没有浏览器打算支持这个属性，因此@supports块中的样式不会被应用
        
        
    @supports ((display: flex) and (pointer:coarse)){   
       .Item { 
          display: inline-flex; 
       } 
    } 
    @supports not (display: flex) { 
       .Item { 
           display: inline-block; 
       } 
    } 
    
    还能用js检查特性	Modernizr脚本
    来创建CSS分支
    ```

#### CSS3选择符

+ ```css
  属性选中符
  img[alt]
  img[alt="sausages"]
  
  1. 以……开头
  img[alt^="film"]
  
  2. 包含……
  [attribute*="value"]
  
  3. 以……结尾
  [attribute$="value"]
  
  [data-film*="awful"][data-film*="moulin-rouge"]{}
  ```

### CSS3结构化伪类

+ **:last-child**

+ **:first-child**

+ 针对只有一项的选择符**:only-child**和唯一一个当前标签的选择符**:only-of-type**

+ **:nth-child**

  + 隔一个选一个**:nth-child(odd)**

  + 偶数**:nth-child(even)**

  + ```css
     nth-child(n)
     nth-last-child(n)
     nth-of-type(n)
     nth-last-of-type(n)
    /*	从第三个开始每隔一个会选中一次	*/
    :nth-child(2n+3)
    :nth-child(-2n+3)	反方向选中
    
    .span-class:nth-of-type(-2n+3)
    虽然所有元素都有相同的类span-class，
    但这里只会选择带有该类的span元素（因为第一个选中的元素的类型是span）。
    
    /* 每4个选1个，但仅限于最后4项 */ 
    .Item:nth-child(4n+1):nth-last-child(-n+4), 
    /* 取得该集合后面的每一项 */ 
    .Item:nth-child(4n+1):nth-last-child(-n+4) ~ .Item
    ```

  + **:not**

    + `:not(.not-me)`	选中不包含(.not-me)

  + **:empty**

    + 选中空元素
    + 有空格不算空元素,只有注释算空元素

  + **::first-line**

    + 选中第一行

#### 自定义属性和变量

+ ```css
  自定义属性创建方法
  :root { 
   --MainFont: 'Helvetica Neue', Helvetica, Arial, sans-serif; 
  }
  引用
  .Title { 
   font-family: var(--MainFont); 
  } 
  
  const vh = document.documentElement.clientHeight;
  document.documentElement.style.setProperty('--view-height', vh+'px');
  操作自定义属性
  ```

+ 计算    `calc(50% - 20px)`

+ **:has**伪类

  + ```css
    暂时不能用
    a:has(figcaption) { 
     padding: 1rem; 
    } 
    这条规则可以给一个包含figcaption的a标签添加内边距。组合使用“取反”伪类，可以
    反转选择范围：
    a:not(:has(figcaption))
    ```

#### 字体

+ @font-face

  + ```CSS
    @font-face { 
        font-family: 'robotoregular'; 
        src: url('Roboto-Regular-webfont.eot'); 
        src: url('Roboto-Regular-webfont.eot?#iefix') format('embeddedopentype'), 
            url('Roboto-Regular-webfont.woff') format('woff'), 
            url('Roboto-Regular-webfont.ttf') format('truetype'), 
            url('Roboto-Regular-webfont.svg#robotoregular') 
            format('svg'); 
        font-weight: normal; 
        font-style: normal; 
    }
    与提供商前缀的机制很类似，浏览器也会依次尝试属性列表中的样式，忽略不能识别的内容
    （属性值越靠下，优先级越高）
    ```