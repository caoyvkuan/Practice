# 响应式布局

## 弹性布局与响应式图片

  ```css
#### 响应式图片

+ ```css
  通过srcset切换分辨率
  <img src="scones_small.jpg" srcset="scones_medium.jpg 1.5x, scones_ large.jpg 2x" alt="Scones taste amazing">
  不过有个问题。1440像素宽、1x的屏幕会拿到跟480像素宽、3x的屏幕相同的图片。这或许
  并不是我们想要的结果。
  
  srcset 及 sizes联合切换
  <img srcset="scones-small.jpg 450w, scones-medium.jpg 900w" sizes="(min-width: 17em) 100vw, (min-width: 40em) 50vw" src="sconessmall. jpg" alt="Scones">
  后缀W告诉浏览器图片有多宽 : 450px	但这里以w为后缀的值并不是“真实”大小，它只是对浏览器的一个提示，大致等于图片的“CSS像素”大小。
  
  picture元素
  
  <picture> /*	按照屏幕大小切换图片	*/
   <source media="(min-width: 30em)" srcset="cake-table.jpg"> 
   <source media="(min-width: 60em)" srcset="cake-shop.jpg"> 
   <img src="scones.jpg" alt="One way or another, you WILL get cake."> 
  </picture> 
  
  <picture> /*这里把WebP指定为优先使用的图片格式。
  			浏览器如果能显示，就显示，如果不能，就使用img标签里的图片。	*/
   <source type="image/webp" srcset="scones-baby-yeah.webp"> 
   <img src="scones-baby-yeah.jpg" alt="Again, you WILL eat cake."> 
  </picture> 
  ```

#### 作废的html特性

+ 主要包括：strike、center、font、acronym、frame和frameset

#### 响应式HTML5视频与内嵌框架

+ video { max-width: 100%; height: auto; } 

+ 内嵌框架

  + ```html
    <style>.embed-container { position: relative; padding-bottom: 56.25%; 
    height: 0; overflow: hidden; max-width: 100%; height: auto; } .embedcontainer 
    iframe, .embed-container object, .embed-container embed { 
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</ 
    style><div class='embed-container'><iframe src='http://www.youtube. com/embed/B1_N28DA3gY' frameborder='0' allowfullscreen></iframe></div> 
    ```

## CSS 新特性

+ 平面滚动面板

  + ```css
    .Scroll_Wrapper { 
        width: 100%; 
        white-space: nowrap; 
        overflow-x: auto; 
        overflow-y: hidden; 
        /* 在WebKiet的触摸设备上出现 */ 
        -webkit-overflow-scrolling: touch; 
        /* 在支持的IE中删除滚动条 */ 
        -ms-overflow-style: none; 
    } ]
    /* 防止WebKit浏览器中出现滚动条 */ 
    .Scroll_Wrapper::-webkit-scrollbar { 
        display: none; 
    }
    .Item { 
        display: inline-flex; 
    }/* 防止WebKit浏览器中出现滚动条 */ 
    .Scroll_Wrapper::-webkit-scrollbar { 
     display: none; 
    }
    ```

  #### 特性查询

  + ```css
    @supports (flashing-sausages: lincolnshire) { 
        body { 
            sausage-sound: sizzling; 
            sausage-color: slighty-burnt; 
            background-color: brown; 
        } 
    } 
    这段样式只有浏览器支持flashing-sausages属性才会应用。我肯定没有浏览器打算支持这个属性，因此@supports块中的样式不会被应用
        
        
    @supports ((display: flex) and (pointer:coarse)){   
       .Item { 
          display: inline-flex; 
       } 
    } 
    @supports not (display: flex) { 
       .Item { 
           display: inline-block; 
       } 
    } 
    
    还能用js检查特性	Modernizr脚本
    来创建CSS分支
    ```

#### 渐变背景创建图案

+ ```css
  .carbon-fibre { 
   margin: 1rem; 
   width: 400px; 
   height: 200px; 
   background: 
   radial-gradient(black 15%, transparent 16%) 0 0, 
   radial-gradient(black 15%, transparent 16%) 8px 8px, 
   radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 0 1px, 
   radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 8px 
  9px; 
   background-color:#282828; 
   background-size:16px 16px; 
  } 
  ```

#### 背景堆叠

+ ```css
  优先级从上到下
  .bg { 		ie8	不支持
   background: 
   url('../img/1.png'), 
   url('../img/2.png'), 
   url('../img/3.png') left bottom, black; 
  } 
  
  背景大小	为每张背景图片设置大小
  background-size: 100% 50%, 300px 400px, auto;
   auto：让图片保持其原生大小。
   cover：保持图片比例，拓展至覆盖整个元素。
   contain：保持图片比例，拓展图片让其最长边保持在元素内部
  
  背景位置
  background-position: top 50px right 80px, 40px 40px, top center;
  
  在“正常”和高清屏幕选择不同分辨率图片
  .bg { 
   background-image: url('bg.jpg'); 
  } 
  /*	1.5dppx（设备像素与CSS像素比）	*/
  @media (min-resolution: 1.5dppx) { 
   .bg { 
  background-image: url('bg@1_5x.jpg'); 
   } 
  } 
  ```

#### 性能

+ 括号外的决定了页面的架构，括号内的决定了页面的性能。
+ 属性增加的效果越多性能消耗越严重\

## SVG

+ SVG的根元素属性

  + width、height和viewbox属性

  + ```css
    viewbox属性可以让你缩放图片。例如：
    <svg width="198px" height="188px" viewBox="0 0 99 94" >
    那么其中的形状为了填满SVG的宽度和高度，就会被放大
    ```

+ 命名空间

  + ```css
    xmlns:sketch="http://www.bohemiancoding.com/sketch/ns"
    这些命名空间往往只是在生成SVG的程序中使用，
    所以在Web页面上展示SVG的时候它们并不是必需的。
    因此在优化流程中，为了减小SVG的大小，通常会把它们去掉
    ```

+ 标题和描述

  + ```xml
    <title>Star 1</title> 
     <desc>Created with Sketch.</desc> 
    当SVG图片被应用为背景图片的时候，可以去除这些标签来减小文件大小
    ```

+ defs 标签

  + 用于储存所有可以复用的元素定义的地方，如梯度、符号、路径等.

+ 元素 g

  + ```html
    g元素能把其他元素捆绑在一起
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fillrule=" 
    evenodd" sketch:type="MSPage"> 
    在g标签中可以看到先前的命名空间。这会有助于图形编辑软件再次打开这个图像，但
    是它对于这个图片在其他地方展示并没有影响
    ```

+ SVG形状元素

  + ```HTML
    <polygon id="Star-1" stroke="#979797" stroke-width="3" fill="#F8E81C" 
    sketch:type="MSShapeGroup" points="99 154 40.2214748 184.901699 
    51.4471742 119.45085 3.89434837 73.0983006 69.6107374 63.5491503 99 
    4 128.389263 63.5491503 194.105652 73.0983006 146.552826 119.45085 
    157.778525 184.901699 "></polygon> 
    
    SVG拥有一系列可用的现成形状（path、rect、circle、ellipse、line、polyline、polygon）。
    ```

+ svg路径

  + SVG路径和其他SVG形状有所区别，因为它们是由任意数量的连接点组成的

#### 在Web页面中插入svg

+ 使用img标签

  + ```HTML
    <img src="mySconeVector.svg" alt="Amazing line art of a scone" />
    ```

+ 使用object标签

  + ```HTML
    <object data="img/svgfile.svg" type="image/svg+xml"> 
        <span class="fallback-info">Your browser doesn't support SVG</span> 
    </object> 
    data URI可以节省网络请求
    ```

+ 把 SVG 作为背景图像插入

  + ```css
    background-image: url('image.svg');
    ```

+ 内联svg

+ ```html
  <svg id="svgInline" width="198" height="188" viewBox="0 0 198 188" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> 
      <title>Star 1</title> 
      <g class="star_Wrapper" fill="none" fill-rule="evenodd"> 
          <path id="star_Path" stroke="#979797" strokewidth="3" fill="#F8E81C" d="M99 154l-58.78 30.902 11.227-65.45L3.894 73.097l65.717-9.55L99 4l29.39 59.55 65.716 9.548-47.553 46.353 11.22665.452z" /> </g> 
  </svg>
  删除掉svg元素的width和height属性，SVG就会自动缩放来填满容器
  ```

## 响应式

+ 首先为最小的视口编写CSS，然后在媒体查询中修改其在较大视口下的表现 ==> 比较轻松

+ 在真实设备上观察和使用设计

+ 拥抱渐进增强

  + 从选择支持的浏览器中选取它们共有的子集方法来开始编写你的前端代码（HTML、CSS、JavaScript）
  + 然后，逐步优化你的代码以适应那些比较强大的浏览器和设备

+ 应专注于正确使用main、header、footer、article、section和aside等元素。

+ 确定需要支持的浏览器

+ 等价的功能，而不是等价的外观

+ 将 CSS 断点与 JavaScript 联系起来

  + 通常，一些页面上的交互都会涉及JavaScript。当你在开发响应式项目的时候，可能想在不同尺寸的视口里看到不同的效果。这既包括CSS也包括JavaScript。

  + ```css
    利用伪元素让javascript识别CSS断点
    
    var size = window.getComputedStyle(document.body,':after').getPropertyValue('content');
    (function alertSize() { 
        if (size.indexOf("Splus") !=-1) { 
            alert('I will run functions for small screens'); 
        } 
        if (size.indexOf("Mplus") !=-1) { 
            alert('At medium sizes, a different function could run'); 
        } 
        if (size.indexOf("Lplus") !=-1) { 
            alert('Large screen here, different functions if needed'); 
        } 
    })(); 
    
    @media (min-width: 20rem) { 
        body::after { 
            content: "Splus"; 
            font-size: 0; 
        } 
    } 
    @media (min-width: 47.5rem) { 
        body::after { 
            content: "Mplus"; 
            font-size: 0; 
        } 
    } 
    @media (min-width: 62.5rem) { 
        body::after { 
            content: "Lplus"; 
            font-size: 0; 
        } 
    }
    ```

+ 在开发中避免使用框架

+ 尽可能使用最简单的代码

  + 例如，如果你需要为列表中的第五个元素添加不同的样式，并且你能操作标记，那就不要像下面这样使用nth-child选择器

  + ```css
    .list-item:nth-child(5) { 
     /* 样式 */ 
    } 
    
    应该提倡这种方式
    <li class="list-item specific-class">Item</li> 
    然后使用类来添加样式：
    .specific-class { 
     /* 样式 */ 
    } 
    ```

+ 根据视口隐藏、展示和加载内容

  + 响应式Web设计中有一个常用的准则：如果你在小屏幕上不加载某一部分，那么在大屏幕上也不应该加载

+ 将复杂的可视化工作交给 CSS

+ 验证器和代码检测工具

+ 性能

  + 减少你的资源数（例如，不要加载15个JavaScript文件，而应该将它们拼成一个）。
  + 减小你的页面大小（如果你能压缩图片，那么请压缩）
  + 延迟加载非必需资源（如果你可以将CSS和JavaScript的加载延迟到页面加载完成后，就可以大幅缩短初始化时间）
  + 保证页面尽快可用（通常是上述所有步骤的副产物）
  + 当你尝试优化性能时，确保在开始前衡量性能表现（否则，你不知道你的优化工作的成果）。然后调整、测试，再重复上述步骤。

+ 延迟加载

  + ```html
    <script>
        setTimeout(function(){
            document.getElementById("img2").setAttribute("src","gq2.jpeg");
            downLoadJs("jquery.js");
            downLoadCss("styles.css");
        },1000);
     
        function downLoadJs(url){
            var elem = document.createElement("script");
            elem.src = url;
            document.body.appendChild(elem);
        }
     
        function downLoadCss(url){
            var elem = document.createElement("link");
            elem.rel = "stylesheet";
            elem.type = "text/css";
            elem.href = url;
            document.body.appendChild(elem);
        }
    </script>
    ```

    

